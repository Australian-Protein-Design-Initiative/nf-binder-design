---
title: "BindCraft Analysis Report"
author: "Australian-Protein-Design-Initiative/nf-binder-design"
date: last-modified
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
    theme: cosmo
    embed-resources: true
jupyter: python3
---

# Overview

This report presents an analysis of the BindCraft design results, including failure metrics, design statistics, MPNN design variations, and trajectory analysis.

```{python}
# | label: setup
# | message: false
# | warning: false

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import warnings

warnings.filterwarnings("ignore")

# Set plotting style
plt.style.use("fast")


# Helper function to safely load CSV files
def safe_load_csv(filename, description):
    try:
        if Path(filename).exists():
            df = pd.read_csv(filename)
            print(f"✓ Loaded {description}: {len(df)} rows, {len(df.columns)} columns")
            return df
        else:
            print(f"⚠ File not found: {filename}")
            return None
    except Exception as e:
        print(f"✗ Error loading {filename}: {e}")
        return None


print(os.getcwd())

# Load all available data files
failure_df = safe_load_csv("failure_csv.csv", "Failure metrics")
final_design_df = safe_load_csv("final_design_stats.csv", "Final design statistics")
mpnn_design_df = safe_load_csv("mpnn_design_stats.csv", "MPNN design statistics")
trajectory_df = safe_load_csv("trajectory_stats.csv", "Trajectory statistics")

print(f"\nData availability summary:")
failure_status = "Available" if failure_df is not None else "Not available"
final_status = "Available" if final_design_df is not None else "Not available"
mpnn_status = "Available" if mpnn_design_df is not None else "Not available"
trajectory_status = "Available" if trajectory_df is not None else "Not available"

print(f"- Failure metrics: {failure_status}")
print(f"- Final design stats: {final_status}")
print(f"- MPNN design stats: {mpnn_status}")
print(f"- Trajectory stats: {trajectory_status}")
```

# Failure Metrics Analysis

The failure metrics provide insight into where designs encountered issues during the BindCraft pipeline.

```{python}
# | label: failure-metrics-trajectory
# | fig-width: 8
# | fig-height: 6

if failure_df is not None and len(failure_df) > 0:
    # Define column ranges for the three plots
    trajectory_cols = ['Trajectory_logits_pLDDT', 'Trajectory_softmax_pLDDT', 'Trajectory_one-hot_pLDDT', 
                      'Trajectory_final_pLDDT', 'Trajectory_Contacts', 'Trajectory_Clashes', 'Trajectory_WrongHotspot',
                      'MPNN_score', 'MPNN_seq_recovery', 'pLDDT', 'pTM', 'i_pTM', 'pAE', 'i_pAE', 'i_pLDDT', 'ss_pLDDT']
    
    # Get available columns that exist in the dataframe
    available_trajectory_cols = [col for col in trajectory_cols if col in failure_df.columns]
    
    if len(available_trajectory_cols) > 0:
        # Get values for trajectory columns
        if len(failure_df) > 1:
            trajectory_values = failure_df[available_trajectory_cols].sum().values
        else:
            trajectory_values = failure_df.iloc[0][available_trajectory_cols].values
        
        # Create trajectory plot
        fig, ax = plt.subplots(figsize=(8, 6))
        bars = ax.bar(range(len(available_trajectory_cols)), trajectory_values, alpha=0.7, color="steelblue")
        
        # Add value labels on bars for non-zero values
        for i, (bar, val) in enumerate(zip(bars, trajectory_values)):
            if val > 0:
                ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                       str(int(val)), ha='center', va='bottom', fontsize=8, fontweight='bold')
        
        ax.set_xlabel("Trajectory Metrics", fontsize=12)
        ax.set_ylabel("Number of Failures", fontsize=12)
        ax.set_title("BindCraft Trajectory Failure Metrics", fontsize=14, fontweight="bold")
        ax.set_xticks(range(len(available_trajectory_cols)))
        ax.set_xticklabels(available_trajectory_cols, rotation=45, ha="right", fontsize=9)
        ax.grid(axis="y", alpha=0.3)
        ax.set_axisbelow(True)
        plt.tight_layout()
        plt.show()
        

```

```{python}
# | label: failure-metrics-structure
# | fig-width: 8
# | fig-height: 6

if failure_df is not None and len(failure_df) > 0:
    # Get all columns from Unrelaxed_Clashes to the last InterfaceAAs_ column
    all_cols = list(failure_df.columns)
    start_idx = all_cols.index('Unrelaxed_Clashes') if 'Unrelaxed_Clashes' in all_cols else 0
    
    # Find the last InterfaceAAs_ column
    interface_cols = [col for col in all_cols if col.startswith('InterfaceAAs_')]
    if interface_cols:
        last_interface_col = max(interface_cols, key=lambda x: all_cols.index(x))
        end_idx = all_cols.index(last_interface_col) + 1
    else:
        end_idx = len(all_cols)
    
    structure_cols = all_cols[start_idx:end_idx]
    
    if len(structure_cols) > 0:
        # Get values for structure columns
        if len(failure_df) > 1:
            structure_values = failure_df[structure_cols].sum().values
        else:
            structure_values = failure_df.iloc[0][structure_cols].values
        
        # Filter out InterfaceAAs_ columns unless they have non-zero values
        filtered_structure_cols = []
        filtered_structure_values = []
        for col, val in zip(structure_cols, structure_values):
            if not col.startswith('InterfaceAAs_') or val > 0:
                filtered_structure_cols.append(col)
                filtered_structure_values.append(val)
        
        if len(filtered_structure_cols) > 0:
            # Create structure plot
            fig, ax = plt.subplots(figsize=(8, 6))
            bars = ax.bar(range(len(filtered_structure_cols)), filtered_structure_values, alpha=0.7, color="coral")
            
            # Add value labels on bars for non-zero values
            for i, (bar, val) in enumerate(zip(bars, filtered_structure_values)):
                if val > 0:
                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                           str(int(val)), ha='center', va='bottom', fontsize=8, fontweight='bold')
            
            ax.set_xlabel("Structure Metrics", fontsize=12)
            ax.set_ylabel("Number of Failures", fontsize=12)
            ax.set_title("BindCraft Structure Failure Metrics", fontsize=14, fontweight="bold")
            ax.set_xticks(range(len(filtered_structure_cols)))
            ax.set_xticklabels(filtered_structure_cols, rotation=45, ha="right", fontsize=9)
            ax.grid(axis="y", alpha=0.3)
            ax.set_axisbelow(True)
            plt.tight_layout()
            plt.show()
            

```

```{python}
# | label: failure-metrics-final
# | fig-width: 8
# | fig-height: 6

if failure_df is not None and len(failure_df) > 0:
    # Get columns from Hotspot_RMSD to the end
    all_cols = list(failure_df.columns)
    start_idx = all_cols.index('Hotspot_RMSD') if 'Hotspot_RMSD' in all_cols else len(all_cols) - 4
    final_cols = all_cols[start_idx:]
    
    if len(final_cols) > 0:
        # Get values for final columns
        if len(failure_df) > 1:
            final_values = failure_df[final_cols].sum().values
        else:
            final_values = failure_df.iloc[0][final_cols].values
        
        # Create final plot
        fig, ax = plt.subplots(figsize=(8, 6))
        bars = ax.bar(range(len(final_cols)), final_values, alpha=0.7, color="lightgreen")
        
        # Add value labels on bars for non-zero values
        for i, (bar, val) in enumerate(zip(bars, final_values)):
            if val > 0:
                ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                       str(int(val)), ha='center', va='bottom', fontsize=8, fontweight='bold')
        
        ax.set_xlabel("Final Metrics", fontsize=12)
        ax.set_ylabel("Number of Failures", fontsize=12)
        ax.set_title("BindCraft Final Failure Metrics", fontsize=14, fontweight="bold")
        ax.set_xticks(range(len(final_cols)))
        ax.set_xticklabels(final_cols, rotation=45, ha="right", fontsize=9)
        ax.grid(axis="y", alpha=0.3)
        ax.set_axisbelow(True)
        plt.tight_layout()
        plt.show()
        

```

# MPNN Design Statistics

Analysis of the designs generated through the MPNN (Message Passing Neural Network) process.

```{python}
#| label: mpnn-design-boxplots
#| fig-width: 12
#| fig-height: 8

        if mpnn_design_df is not None and len(mpnn_design_df) > 0:
            # Key metrics for box plots (excluding dG metrics)
            key_metrics = ['MPNN_score', 'MPNN_seq_recovery', 'Average_pLDDT', 'Average_pTM',
                           'Average_i_pTM', 'Average_i_pAE', 'Average_ShapeComplementarity']
            available_metrics = [col for col in key_metrics if col in mpnn_design_df.columns]

            if available_metrics:
                # Create single box plot with all metrics (excluding dG)
                fig, ax = plt.subplots(figsize=(8, 6))

                # Prepare data for box plot
                plot_data = []
                labels = []

                for metric in available_metrics:
                    data = mpnn_design_df[metric].dropna()
                    if len(data) > 0:
                        plot_data.append(data.values)
                        labels.append(metric)

                if plot_data:
                    # Create box plot
                    bp = ax.boxplot(plot_data, patch_artist=True, labels=labels)

                    # Color the boxes
                    for patch in bp['boxes']:
                        patch.set_facecolor('lightblue')
                    for median in bp['medians']:
                        median.set_color('red')

                    # Add individual points
                    for i, data in enumerate(plot_data):
                        x_points = np.ones(len(data)) * (i + 1)  # Position points at box locations
                        ax.plot(x_points, data, 'o', color='darkblue', alpha=0.6, markersize=4)

                    ax.set_xlabel('MPNN Metrics', fontsize=12)
                    ax.set_ylabel('Value', fontsize=12)
                    ax.set_title('MPNN Design Metrics Distribution', fontsize=14, fontweight='bold')
                    ax.tick_params(axis='x', rotation=45)
                    ax.set_xticklabels(labels, rotation=45, ha='right')
                    ax.grid(True, alpha=0.3)
                    plt.tight_layout()
                    plt.show()

            # Separate box plot for Average_dG
            if 'Average_dG' in mpnn_design_df.columns:
                dg_data = mpnn_design_df['Average_dG'].dropna()
                if len(dg_data) > 0:
                    fig, ax = plt.subplots(figsize=(8, 6))
                    
                    # Create box plot for dG
                    bp = ax.boxplot(dg_data.values, patch_artist=True, labels=['Average_dG'])
                    
                    # Color the box
                    bp['boxes'][0].set_facecolor('lightcoral')
                    bp['medians'][0].set_color('red')
                    
                    # Add individual points
                    ax.plot(np.ones(len(dg_data)), dg_data.values, 'o', color='darkred', alpha=0.6, markersize=4)
                    
                    ax.set_xlabel('Metric', fontsize=12)
                    ax.set_ylabel('dG Value', fontsize=12)
                    ax.set_title('Average dG Distribution', fontsize=14, fontweight='bold')
                    ax.grid(True, alpha=0.3)
                    plt.tight_layout()
                    plt.show()
```

```{python}
#| label: mpnn-design-ranking
#| message: false

if mpnn_design_df is not None and len(mpnn_design_df) > 0:
    # Define columns to show in the table
    table_cols = ['Design', 'Average_i_pTM', 'Average_i_pAE', 'Average_pLDDT', 'Average_pTM', 
                  'Average_dG', 'Average_ShapeComplementarity', 'Length']
    available_table_cols = [col for col in table_cols if col in mpnn_design_df.columns]
    
    if available_table_cols and 'Design' in mpnn_design_df.columns:
        # Create ranking table sorted by Average_i_pTM
        ranking_df = mpnn_design_df[available_table_cols].copy()
        ranking_df = ranking_df.sort_values('Average_i_pTM', ascending=False)
        
        # Display top 20 designs
        print("\nTop MPNN Designs (ranked by Average_i_pTM):")
        display_df = ranking_df.head(20)
        
        # Format numeric columns - Length as integer, others as float
        numeric_cols = [col for col in available_table_cols if col != 'Design']
        format_dict = {}
        for col in numeric_cols:
            if col == 'Length':
                format_dict[col] = '{:.0f}'  # Integer format
            else:
                format_dict[col] = '{:.3f}'  # Float format
        
        styled_table = display_df.style.format(format_dict) \
                                     .background_gradient(cmap='RdYlGn', subset=['Average_i_pTM']) \
                                     .hide(axis='index')
        display(styled_table)
```

# Trajectory Analysis

Analysis of the design trajectory and final structures.

```{python}
#| label: trajectory-boxplots
#| fig-width: 12
#| fig-height: 8

        if trajectory_df is not None and len(trajectory_df) > 0:
            # Key trajectory metrics for box plots (excluding dG)
            trajectory_metrics = ['pLDDT', 'pTM', 'i_pTM', 'pAE', 'i_pAE', 'ShapeComplementarity', 'Target_RMSD']
            available_traj_metrics = [col for col in trajectory_metrics if col in trajectory_df.columns]

            if available_traj_metrics:
                # Create single box plot with all metrics (excluding dG)
                fig, ax = plt.subplots(figsize=(8, 6))

                # Prepare data for box plot
                plot_data = []
                labels = []

                for metric in available_traj_metrics:
                    data = trajectory_df[metric].dropna()
                    if len(data) > 0:
                        plot_data.append(data.values)
                        labels.append(metric)

                if plot_data:
                    # Create box plot
                    bp = ax.boxplot(plot_data, patch_artist=True, labels=labels)

                    # Color the boxes
                    for patch in bp['boxes']:
                        patch.set_facecolor('lightgreen')
                    for median in bp['medians']:
                        median.set_color('red')

                    # Add individual points
                    for i, data in enumerate(plot_data):
                        x_points = np.ones(len(data)) * (i + 1)  # Position points at box locations
                        ax.plot(x_points, data, 'o', color='darkgreen', alpha=0.6, markersize=4)

                    ax.set_xlabel('Trajectory Metrics', fontsize=12)
                    ax.set_ylabel('Value', fontsize=12)
                    ax.set_title('Trajectory Analysis Metrics Distribution', fontsize=14, fontweight='bold')
                    ax.tick_params(axis='x', rotation=45)
                    ax.set_xticklabels(labels, rotation=45, ha='right')
                    ax.grid(True, alpha=0.3)
                    plt.tight_layout()
                    plt.show()

            # Separate box plot for dG
            if 'dG' in trajectory_df.columns:
                dg_data = trajectory_df['dG'].dropna()
                if len(dg_data) > 0:
                    fig, ax = plt.subplots(figsize=(8, 6))
                    
                    # Create box plot for dG
                    bp = ax.boxplot(dg_data.values, patch_artist=True, labels=['dG'])
                    
                    # Color the box
                    bp['boxes'][0].set_facecolor('lightcoral')
                    bp['medians'][0].set_color('red')
                    
                    # Add individual points
                    ax.plot(np.ones(len(dg_data)), dg_data.values, 'o', color='darkred', alpha=0.6, markersize=4)
                    
                    ax.set_xlabel('Metric', fontsize=12)
                    ax.set_ylabel('dG Value', fontsize=12)
                    ax.set_title('dG Distribution', fontsize=14, fontweight='bold')
                    ax.grid(True, alpha=0.3)
                    plt.tight_layout()
                    plt.show()
```

```{python}
#| label: trajectory-ranking
#| message: false

if trajectory_df is not None and len(trajectory_df) > 0:
    # Define columns to show in the table
    table_cols = ['Design', 'i_pTM', 'i_pAE', 'pLDDT', 'pTM', 'dG', 'ShapeComplementarity', 'Target_RMSD', 'Length', 
                  'pAE', 'i_pLDDT', 'ss_pLDDT', 'Unrelaxed_Clashes', 'Relaxed_Clashes', 'Binder_Energy_Score', 
                  'Surface_Hydrophobicity', 'PackStat', 'dSASA', 'dG/dSASA', 'Interface_SASA_%', 'Interface_Hydrophobicity',
                  'n_InterfaceResidues', 'n_InterfaceHbonds', 'InterfaceHbondsPercentage', 'n_InterfaceUnsatHbonds',
                  'InterfaceUnsatHbondsPercentage', 'Interface_Helix%', 'Interface_BetaSheet%', 'Interface_Loop%',
                  'Binder_Helix%', 'Binder_BetaSheet%', 'Binder_Loop%']
    available_table_cols = [col for col in table_cols if col in trajectory_df.columns]
    
    if available_table_cols and 'Design' in trajectory_df.columns:
        # Create ranking table sorted by i_pTM
        ranking_df = trajectory_df[available_table_cols].copy()
        ranking_df = ranking_df.sort_values('i_pTM', ascending=False)
        
        # Display top 20 designs (or less if fewer available)
        print("\nTop Trajectory Designs (ranked by i_pTM):")
        display_df = ranking_df.head(20)
        
        # Format numeric columns - Length as integer, others as float
        numeric_cols = [col for col in available_table_cols if col != 'Design']
        format_dict = {}
        for col in numeric_cols:
            if col == 'Length':
                format_dict[col] = '{:.0f}'  # Integer format
            else:
                format_dict[col] = '{:.3f}'  # Float format
        
        styled_table = display_df.style.format(format_dict) \
                                     .background_gradient(cmap='RdYlGn', subset=['i_pTM']) \
                                     .hide(axis='index')
        display(styled_table)
```

# Final Design Statistics

Analysis of the final design statistics (if available).

```{python}
#| label: final-design-main-boxplots
#| fig-width: 8
#| fig-height: 6

if final_design_df is not None and len(final_design_df) > 0:
    # Key final design metrics for box plots (excluding dG)
    final_metrics = ['Average_pLDDT', 'Average_pTM', 'Average_i_pTM', 'Average_i_pAE', 'Average_ShapeComplementarity', 
                     'Average_ss_pLDDT', 'Average_Unrelaxed_Clashes', 'Average_Relaxed_Clashes', 'Average_Binder_Energy_Score',
                     'Average_Surface_Hydrophobicity', 'Average_PackStat', 'Average_Interface_SASA_%', 'Average_Interface_Hydrophobicity',
                     'Average_n_InterfaceResidues', 'Average_n_InterfaceHbonds', 'Average_InterfaceHbondsPercentage',
                     'Average_n_InterfaceUnsatHbonds', 'Average_InterfaceUnsatHbondsPercentage', 'Average_Interface_Helix%',
                     'Average_Interface_BetaSheet%', 'Average_Interface_Loop%', 'Average_Binder_Helix%', 'Average_Binder_BetaSheet%',
                     'Average_Binder_Loop%', 'Average_Hotspot_RMSD', 'Average_Target_RMSD', 'Average_Binder_pLDDT', 'Average_Binder_pTM',
                     'Average_Binder_pAE', 'Average_Binder_RMSD']
    available_final_metrics = [col for col in final_metrics if col in final_design_df.columns]

    if available_final_metrics:
        # Main metrics (excluding dG, Binder_Energy_Score, Interface_Hydrophobicity, n_* metrics, Clashes, and RMSD)
        main_metrics = [metric for metric in available_final_metrics 
                       if metric not in ['Average_Binder_Energy_Score', 'Average_dG', 'Average_Interface_Hydrophobicity'] 
                       and not metric.startswith('Average_n_')
                       and 'Clashes' not in metric and 'RMSD' not in metric]
        
        # Create main box plot
        if main_metrics:
            fig, ax = plt.subplots(figsize=(8, 6))
            plot_data = []
            labels = []

            for metric in main_metrics:
                data = final_design_df[metric].dropna()
                if len(data) > 0:
                    # Convert percentage columns to proportions (0-1 scale)
                    if any(percent_suffix in metric for percent_suffix in ['%', 'Percentage']):
                        data = data / 100.0
                        # Update label to indicate it's now a proportion
                        label = metric.replace('Percentage', 'Prop').replace('%', '_prop')
                    else:
                        label = metric
                    
                    plot_data.append(data.values)
                    labels.append(label)

            if plot_data:
                # Create box plot
                bp = ax.boxplot(plot_data, patch_artist=True, labels=labels)

                # Color the boxes
                for patch in bp['boxes']:
                    patch.set_facecolor('lightsteelblue')
                for median in bp['medians']:
                    median.set_color('red')

                # Add individual points
                for i, data in enumerate(plot_data):
                    x_points = np.ones(len(data)) * (i + 1)  # Position points at box locations
                    ax.plot(x_points, data, 'o', color='darkblue', alpha=0.6, markersize=4)

                ax.set_xlabel('Final Design Metrics', fontsize=12)
                ax.set_ylabel('Value', fontsize=12)
                ax.set_title('Final Design Metrics Distribution', fontsize=14, fontweight='bold')
                ax.tick_params(axis='x', rotation=45)
                ax.set_xticklabels(labels, rotation=45, ha='right')
                ax.grid(True, alpha=0.3)
                plt.tight_layout()
                plt.show()
```

```{python}
# | label: final-design-tiled-boxplots
# | fig-width: 3
# | fig-height: 6

if final_design_df is not None and len(final_design_df) > 0:
    # Tiled box plots for Interface Hydrophobicity and n_* metrics
    tiled_metrics = []
    if "Average_Interface_Hydrophobicity" in final_design_df.columns:
        tiled_metrics.append("Average_Interface_Hydrophobicity")
    tiled_metrics.extend(
        [col for col in available_final_metrics if col.startswith("Average_n_")]
    )

    if tiled_metrics:
        # Calculate grid dimensions
        n_plots = len(tiled_metrics)
        cols = min(4, n_plots)  # Max 4 columns
        rows = (n_plots + cols - 1) // cols  # Ceiling division

        fig, axes = plt.subplots(
            rows, cols, figsize=(2 * cols, 2 * rows)
        )  # Same height as standalone
        if n_plots == 1:
            axes = [axes]
        elif rows == 1:
            axes = axes.reshape(1, -1)
        elif cols == 1:
            axes = axes.reshape(-1, 1)

        for i, metric in enumerate(tiled_metrics):
            row = i // cols
            col = i % cols
            ax = axes[row, col]

            data = final_design_df[metric].dropna()
            if len(data) > 0:
                # Create box plot
                bp = ax.boxplot(data.values, patch_artist=True, labels=[metric])

                # Color the box
                bp["boxes"][0].set_facecolor("lightcoral")
                bp["medians"][0].set_color("red")

                # Add individual points
                x_points = np.ones(
                    len(data)
                )  # Create array of ones matching data length
                ax.plot(
                    x_points, data.values, "o", color="darkred", alpha=0.6, markersize=4
                )

                ax.grid(True, alpha=0.3)
                ax.tick_params(axis="x", rotation=45)

        # Hide empty subplots
        for i in range(n_plots, rows * cols):
            row = i // cols
            col = i % cols
            axes[row, col].set_visible(False)

        plt.tight_layout()
        plt.show()
```

```{python}
# | label: final-design-standalone-boxplots
# | fig-width: 3
# | fig-height: 6

if final_design_df is not None and len(final_design_df) > 0:
    # Side-by-side standalone box plots
    standalone_plots = []

    # Collect all standalone plots
    if "Average_Binder_Energy_Score" in final_design_df.columns:
        standalone_plots.append(("Average_Binder_Energy_Score", ""))
    if "Average_dG" in final_design_df.columns:
        standalone_plots.append(("Average_dG", ""))

    # Add Clashes metrics
    clashes_metrics = [col for col in available_final_metrics if "Clashes" in col]
    if clashes_metrics:
        standalone_plots.append(("clashes_group", ""))

    # Add RMSD metrics
    rmsd_metrics = [col for col in available_final_metrics if "RMSD" in col]
    if rmsd_metrics:
        standalone_plots.append(("rmsd_group", ""))

    if standalone_plots:
        n_standalone = len(standalone_plots)
        fig, axes = plt.subplots(
            1, n_standalone, figsize=(2 * n_standalone, 6)
        )  # Even narrower width
        if n_standalone == 1:
            axes = [axes]

        for i, (plot_type, title) in enumerate(standalone_plots):
            ax = axes[i]

            if plot_type == "clashes_group":
                # Create box plot for all Clashes metrics
                plot_data = []
                labels = []
                for metric in clashes_metrics:
                    data = final_design_df[metric].dropna()
                    if len(data) > 0:
                        plot_data.append(data.values)
                        labels.append(metric)

                if plot_data:
                    bp = ax.boxplot(plot_data, patch_artist=True, labels=labels)
                    for patch in bp["boxes"]:
                        patch.set_facecolor("lightcoral")
                    for median in bp["medians"]:
                        median.set_color("red")

                    # Add individual points
                    for j, data in enumerate(plot_data):
                        x_points = np.ones(len(data)) * (j + 1)
                        ax.plot(
                            x_points,
                            data,
                            "o",
                            color="darkred",
                            alpha=0.6,
                            markersize=4,
                        )

                    ax.set_xticklabels(labels, rotation=45, ha="right")

            elif plot_type == "rmsd_group":
                # Create box plot for all RMSD metrics
                plot_data = []
                labels = []
                for metric in rmsd_metrics:
                    data = final_design_df[metric].dropna()
                    if len(data) > 0:
                        plot_data.append(data.values)
                        labels.append(metric)

                if plot_data:
                    bp = ax.boxplot(plot_data, patch_artist=True, labels=labels)
                    for patch in bp["boxes"]:
                        patch.set_facecolor("lightcoral")
                    for median in bp["medians"]:
                        median.set_color("red")

                    # Add individual points
                    for j, data in enumerate(plot_data):
                        x_points = np.ones(len(data)) * (j + 1)
                        ax.plot(
                            x_points,
                            data,
                            "o",
                            color="darkred",
                            alpha=0.6,
                            markersize=4,
                        )

                    ax.set_xticklabels(labels, rotation=45, ha="right")

            else:
                # Single metric box plot
                data = final_design_df[plot_type].dropna()
                if len(data) > 0:
                    bp = ax.boxplot(data.values, patch_artist=True, labels=[plot_type])
                    bp["boxes"][0].set_facecolor("lightcoral")
                    bp["medians"][0].set_color("red")

                    x_points = np.ones(len(data))
                    ax.plot(
                        x_points,
                        data.values,
                        "o",
                        color="darkred",
                        alpha=0.6,
                        markersize=4,
                    )

            ax.grid(True, alpha=0.3)
            ax.tick_params(axis="x", rotation=45)

        plt.tight_layout()
        plt.show()
```

```{python}
#| label: final-design-ranking
#| message: false

if final_design_df is not None and len(final_design_df) > 0:
    # Define columns to show in the table
    table_cols = ['Design', 'Average_i_pTM', 'Average_i_pAE', 'Average_pLDDT', 'Average_pTM', 'Average_dG', 
                  'Average_ShapeComplementarity', 'Average_Target_RMSD', 'Length', 'Average_ss_pLDDT', 
                  'Average_Unrelaxed_Clashes', 'Average_Relaxed_Clashes', 'Average_Binder_Energy_Score',
                  'Average_Surface_Hydrophobicity', 'Average_PackStat', 'Average_Interface_SASA_%', 
                  'Average_Interface_Hydrophobicity', 'Average_n_InterfaceResidues', 'Average_n_InterfaceHbonds',
                  'Average_InterfaceHbondsPercentage', 'Average_n_InterfaceUnsatHbonds', 'Average_InterfaceUnsatHbondsPercentage',
                  'Average_Interface_Helix%', 'Average_Interface_BetaSheet%', 'Average_Interface_Loop%',
                  'Average_Binder_Helix%', 'Average_Binder_BetaSheet%', 'Average_Binder_Loop%', 'Average_Hotspot_RMSD',
                  'Average_Binder_pLDDT', 'Average_Binder_pTM', 'Average_Binder_pAE', 'Average_Binder_RMSD']
    available_table_cols = [col for col in table_cols if col in final_design_df.columns]
    
    if available_table_cols and 'Design' in final_design_df.columns:
        # Create ranking table sorted by Average_i_pTM
        ranking_df = final_design_df[available_table_cols].copy()
        ranking_df = ranking_df.sort_values('Average_i_pTM', ascending=False)
        
        # Display top 20 designs (or less if fewer available)
        print("\nTop Final Designs (ranked by Average_i_pTM):")
        display_df = ranking_df.head(20)
        
        # Format numeric columns - Length as integer, others as float
        numeric_cols = [col for col in available_table_cols if col != 'Design']
        format_dict = {}
        for col in numeric_cols:
            if col == 'Length':
                format_dict[col] = '{:.0f}'  # Integer format
            else:
                format_dict[col] = '{:.3f}'  # Float format
        
        styled_table = display_df.style.format(format_dict) \
                                     .background_gradient(cmap='RdYlGn', subset=['Average_i_pTM']) \
                                     .hide(axis='index')
        display(styled_table)
```


