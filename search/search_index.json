{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nf-binder-design Nextflow pipelines for de novo protein binder design. Overview This project provides Nextflow workflows for de novo design of protein binders: RFdiffusion \u2192 ProteinMPNN \u2192 AlphaFold2(initial guess) \u2192 Boltz-2 refolding pipeline RFdiffusion Partial Diffusion \u2192 Boltz-2 refolding for diversification and optimization BindCraft - parallel execution across multiple GPUs BoltzGen - design proteins and complexes using BoltzGen Boltz Pulldown - an AlphaPulldown-like protocol using Boltz-2 Features Flexible workflow options for different binder design strategies HPC-ready with support for SLURM and other job schedulers Multi-GPU parallelization for BindCraft trajectories Plugin system for custom design filters Comprehensive reporting with HTML outputs and summary statistics Quick Links Setup Instructions RFdiffusion Workflows BindCraft Workflow BoltzGen Workflow Boltz Pulldown Utility Scripts GitHub Repository Examples Directory License The pipeline code the comprises nf-binder-design is licensed under the MIT License. Note that some dependencies, packaged externally as containers, are under less permissive licenses: \u26a0\ufe0f \"Commercial Use Restrictions\" Components of these workflows use RFdiffusion and BindCraft, which depend on PyRosetta/Rosetta. These are free for non-commercial use only . Commercial use requires a paid license agreement with University of Washington. See: Rosetta License Rosetta Licensing FAQ Citing If you use nf-binder-design in your research, please cite: Perry, A., Taveneau, C., & Knott, G. J. (2025). nf-binder-design: a Nextflow pipeline for protein binder design (0.1.5). Zenodo. https://doi.org/10.5281/zenodo.16809705 and include citations for the underlying tools used in the workflow as appropriate: RFdiffusion Watson, J.L., Juergens, D., Bennett, N.R. et al. \"De novo design of protein structure and function with RFdiffusion.\", Nature , 620 , 1089\u20131100 (2023). https://doi.org/10.1038/s41586-023-06415-8 Bennett, N.R., Coventry, B., Goreshnik, I. et al. Improving de novo protein binder design with deep learning. Nat Commun , 14 , 2625 (2023). https://doi.org/10.1038/s41467-023-38328-5 ProteinMPNN Dauparas, J. et al. Robust deep learning\u2013based protein sequence design using ProteinMPNN. Science , 378 ,49-56(2022). https://doi.org/10.1126/science.add2187 Alphafold2 Jumper, J. et al. Highly accurate protein structure prediction with AlphaFold. Nature 596, 583\u2013589 (2021). https://doi.org/10.1038/s41586-021-03819-2 BindCraft Pacesa, M., Nickel, L., Schellhaas, C. et al. One-shot design of functional protein binders with BindCraft. Nature , 645 , 1005-1010 (2025). https://doi.org/10.1038/s41586-025-09429-6 Boltz Passaro, S., Corso, G., Wohlwend, J. et al. Boltz-2: Towards Accurate and Efficient Binding Affinity Prediction. bioRxiv (2025). https://doi.org/10.1101/2025.06.14.659707 Wohlwend, J., Corso, G., Passaro, S. et al. Boltz-1: Democratizing Biomolecular Interaction Modeling. bioRxiv (2024). https://doi.org/10.1101/2024.11.19.624167 ColabFold Mirdita, M., Sch\u00fctze, K., Moriwaki, Y. et al. ColabFold: making protein folding accessible to all. Nature Methods , 19 , 679-682 (2022). https://doi.org/10.1038/s41592-022-01488-1 BoltzGen Stark, H., et al. \"BoltzGen: Toward Universal Binder Design.\" Preprint (2025). https://hannes-stark.com/assets/boltzgen.pdf (accessed November 10, 2025).","title":"Home"},{"location":"#nf-binder-design","text":"Nextflow pipelines for de novo protein binder design.","title":"nf-binder-design"},{"location":"#overview","text":"This project provides Nextflow workflows for de novo design of protein binders: RFdiffusion \u2192 ProteinMPNN \u2192 AlphaFold2(initial guess) \u2192 Boltz-2 refolding pipeline RFdiffusion Partial Diffusion \u2192 Boltz-2 refolding for diversification and optimization BindCraft - parallel execution across multiple GPUs BoltzGen - design proteins and complexes using BoltzGen Boltz Pulldown - an AlphaPulldown-like protocol using Boltz-2","title":"Overview"},{"location":"#features","text":"Flexible workflow options for different binder design strategies HPC-ready with support for SLURM and other job schedulers Multi-GPU parallelization for BindCraft trajectories Plugin system for custom design filters Comprehensive reporting with HTML outputs and summary statistics","title":"Features"},{"location":"#quick-links","text":"Setup Instructions RFdiffusion Workflows BindCraft Workflow BoltzGen Workflow Boltz Pulldown Utility Scripts GitHub Repository Examples Directory","title":"Quick Links"},{"location":"#license","text":"The pipeline code the comprises nf-binder-design is licensed under the MIT License. Note that some dependencies, packaged externally as containers, are under less permissive licenses: \u26a0\ufe0f \"Commercial Use Restrictions\" Components of these workflows use RFdiffusion and BindCraft, which depend on PyRosetta/Rosetta. These are free for non-commercial use only . Commercial use requires a paid license agreement with University of Washington. See: Rosetta License Rosetta Licensing FAQ","title":"License"},{"location":"#citing","text":"If you use nf-binder-design in your research, please cite: Perry, A., Taveneau, C., & Knott, G. J. (2025). nf-binder-design: a Nextflow pipeline for protein binder design (0.1.5). Zenodo. https://doi.org/10.5281/zenodo.16809705 and include citations for the underlying tools used in the workflow as appropriate: RFdiffusion Watson, J.L., Juergens, D., Bennett, N.R. et al. \"De novo design of protein structure and function with RFdiffusion.\", Nature , 620 , 1089\u20131100 (2023). https://doi.org/10.1038/s41586-023-06415-8 Bennett, N.R., Coventry, B., Goreshnik, I. et al. Improving de novo protein binder design with deep learning. Nat Commun , 14 , 2625 (2023). https://doi.org/10.1038/s41467-023-38328-5 ProteinMPNN Dauparas, J. et al. Robust deep learning\u2013based protein sequence design using ProteinMPNN. Science , 378 ,49-56(2022). https://doi.org/10.1126/science.add2187 Alphafold2 Jumper, J. et al. Highly accurate protein structure prediction with AlphaFold. Nature 596, 583\u2013589 (2021). https://doi.org/10.1038/s41586-021-03819-2 BindCraft Pacesa, M., Nickel, L., Schellhaas, C. et al. One-shot design of functional protein binders with BindCraft. Nature , 645 , 1005-1010 (2025). https://doi.org/10.1038/s41586-025-09429-6 Boltz Passaro, S., Corso, G., Wohlwend, J. et al. Boltz-2: Towards Accurate and Efficient Binding Affinity Prediction. bioRxiv (2025). https://doi.org/10.1101/2025.06.14.659707 Wohlwend, J., Corso, G., Passaro, S. et al. Boltz-1: Democratizing Biomolecular Interaction Modeling. bioRxiv (2024). https://doi.org/10.1101/2024.11.19.624167 ColabFold Mirdita, M., Sch\u00fctze, K., Moriwaki, Y. et al. ColabFold: making protein folding accessible to all. Nature Methods , 19 , 679-682 (2022). https://doi.org/10.1038/s41592-022-01488-1 BoltzGen Stark, H., et al. \"BoltzGen: Toward Universal Binder Design.\" Preprint (2025). https://hannes-stark.com/assets/boltzgen.pdf (accessed November 10, 2025).","title":"Citing"},{"location":"setup/","text":"Setup Prerequisites Install Nextflow Follow the official Nextflow installation guide . Nextflow requires: Java 11 or later Linux or macOS (Windows via WSL2) The quick version is: # Optional, if you don't have Java 17+ # Check your Java version # java -version # Install Java 17+, if you don't have it # curl -s https://get.sdkman.io | bash # sdk install java 17.0.10-tem # Install Nextflow curl -s https://get.nextflow.io | bash chmod +x nextflow mv nextflow $HOME/.local/bin/ # Ensure $HOME/.local/bin/ is on your PATH # you should also add this line to your ~/.bashrc or ~/.zshrc if required export PATH=\"$PATH:$HOME/.local/bin\" # Test it works nextflow info Clone the repository using git For development, it's often more convenient to clone the git repository directly: git clone https://github.com/Australian-Protein-Design-Initiative/nf-binder-design cd nf-binder-design # See the help as a first test nextflow run main.nf --help Alternative: pull using Nextflow To pre-cache the nf-binder-design repository in ~/.nextflow/assets/ , run: nextflow pull Australian-Protein-Design-Initiative/nf-binder-design you can pull a specific version like: nextflow pull -r 0.1.5 Australian-Protein-Design-Initiative/nf-binder-design Test that you have successfully cached the repository by running: nextflow run Australian-Protein-Design-Initiative/nf-binder-design/main.nf --help Note: The documentation examples currently assume you have git clone 'd the repository, but can be adapted to use this alternative method. In this case, platform-specific config files will be in ~/.nextflow/assets/Australian-Protein-Design-Initiative/nf-binder-design/conf/platforms/ - in the future these will be turned into config profiles to simplify usage. Container Setup These workflows use Apptainer containers for reproducibility. You'll typically need Apptainer installed - this is usually already available on modern HPC clusters. Containers are automatically downloaded when running the pipeline - you will need ~60Gb+ of storage space for the containers. Model weights / parameters are currently packaged inside the containers - this makes the containers large, but simplifies the workflow setup. In the future we will very likely provide more compact alternative containers without weights. Platform-Specific Configuration Local Workstation / single compute node For local execution of a single compute node, use the -profile local flag when running workflows. See examples/pdl1-rfd/nextflow.dual-gpu.config for a config example using dual-GPUs. HPC Clusters with SLURM For running using the SLURM executor, use the -profile slurm flag (this is the default profile if not specified). Some site-specific configurations for HPC clusters and cloud platforms can be applied via eg -profile m3 . Currently defined sites are: m3 - the Monash M3 HPC cluster, generic GPU partitions m3_bdi - the Monash M3 cluster with access to the bdi partitions mlerp - the MLeRP HPC cluster hyperqueue - for running on a generic HyperQueue ( hq ) cluster These configuration files are provided in conf/platforms/ and be copied and adapted for your specific setup. Pull requests for additional HPC clusters are welcome! In addition (on instead of) using a pre-defined -profile , you can use the -c flag to specify the path to a configuration file: nextflow run main.nf -c conf/platforms/m3.config # etc ... HPC Cluster environment variables Set up your Apptainer cache directory to store downloaded containers: # Add to your ~/.bashrc or set before running export APPTAINER_CACHEDIR=${HOME}/.apptainer/cache export NXF_APPTAINER_CACHEDIR=${APPTAINER_CACHEDIR} Changing this location is particularly important on HPC clusters where you may have limited space in your home directory. Ensure your temporary directory is set to a location with sufficient space, eg: export TMPDIR=/scratch2/myproject/tmp export NXF_TEMP=$TMPDIR mkdir -p $TMPDIR Next Steps See the Usage page for examples and detailed workflow documentation.","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#prerequisites","text":"","title":"Prerequisites"},{"location":"setup/#install-nextflow","text":"Follow the official Nextflow installation guide . Nextflow requires: Java 11 or later Linux or macOS (Windows via WSL2) The quick version is: # Optional, if you don't have Java 17+ # Check your Java version # java -version # Install Java 17+, if you don't have it # curl -s https://get.sdkman.io | bash # sdk install java 17.0.10-tem # Install Nextflow curl -s https://get.nextflow.io | bash chmod +x nextflow mv nextflow $HOME/.local/bin/ # Ensure $HOME/.local/bin/ is on your PATH # you should also add this line to your ~/.bashrc or ~/.zshrc if required export PATH=\"$PATH:$HOME/.local/bin\" # Test it works nextflow info","title":"Install Nextflow"},{"location":"setup/#clone-the-repository-using-git","text":"For development, it's often more convenient to clone the git repository directly: git clone https://github.com/Australian-Protein-Design-Initiative/nf-binder-design cd nf-binder-design # See the help as a first test nextflow run main.nf --help","title":"Clone the repository using git"},{"location":"setup/#alternative-pull-using-nextflow","text":"To pre-cache the nf-binder-design repository in ~/.nextflow/assets/ , run: nextflow pull Australian-Protein-Design-Initiative/nf-binder-design you can pull a specific version like: nextflow pull -r 0.1.5 Australian-Protein-Design-Initiative/nf-binder-design Test that you have successfully cached the repository by running: nextflow run Australian-Protein-Design-Initiative/nf-binder-design/main.nf --help Note: The documentation examples currently assume you have git clone 'd the repository, but can be adapted to use this alternative method. In this case, platform-specific config files will be in ~/.nextflow/assets/Australian-Protein-Design-Initiative/nf-binder-design/conf/platforms/ - in the future these will be turned into config profiles to simplify usage.","title":"Alternative: pull using Nextflow"},{"location":"setup/#container-setup","text":"These workflows use Apptainer containers for reproducibility. You'll typically need Apptainer installed - this is usually already available on modern HPC clusters. Containers are automatically downloaded when running the pipeline - you will need ~60Gb+ of storage space for the containers. Model weights / parameters are currently packaged inside the containers - this makes the containers large, but simplifies the workflow setup. In the future we will very likely provide more compact alternative containers without weights.","title":"Container Setup"},{"location":"setup/#platform-specific-configuration","text":"","title":"Platform-Specific Configuration"},{"location":"setup/#local-workstation-single-compute-node","text":"For local execution of a single compute node, use the -profile local flag when running workflows. See examples/pdl1-rfd/nextflow.dual-gpu.config for a config example using dual-GPUs.","title":"Local Workstation / single compute node"},{"location":"setup/#hpc-clusters-with-slurm","text":"For running using the SLURM executor, use the -profile slurm flag (this is the default profile if not specified). Some site-specific configurations for HPC clusters and cloud platforms can be applied via eg -profile m3 . Currently defined sites are: m3 - the Monash M3 HPC cluster, generic GPU partitions m3_bdi - the Monash M3 cluster with access to the bdi partitions mlerp - the MLeRP HPC cluster hyperqueue - for running on a generic HyperQueue ( hq ) cluster These configuration files are provided in conf/platforms/ and be copied and adapted for your specific setup. Pull requests for additional HPC clusters are welcome! In addition (on instead of) using a pre-defined -profile , you can use the -c flag to specify the path to a configuration file: nextflow run main.nf -c conf/platforms/m3.config # etc ...","title":"HPC Clusters with SLURM"},{"location":"setup/#hpc-cluster-environment-variables","text":"Set up your Apptainer cache directory to store downloaded containers: # Add to your ~/.bashrc or set before running export APPTAINER_CACHEDIR=${HOME}/.apptainer/cache export NXF_APPTAINER_CACHEDIR=${APPTAINER_CACHEDIR} Changing this location is particularly important on HPC clusters where you may have limited space in your home directory. Ensure your temporary directory is set to a location with sufficient space, eg: export TMPDIR=/scratch2/myproject/tmp export NXF_TEMP=$TMPDIR mkdir -p $TMPDIR","title":"HPC Cluster environment variables"},{"location":"setup/#next-steps","text":"See the Usage page for examples and detailed workflow documentation.","title":"Next Steps"},{"location":"extra/utility-scripts/","text":"Utility Scripts The bin/ directory contains utility scripts that are used internally by the workflows but can also be run as standalone tools. Running Scripts Run with uv for automatic dependency management - each script has a --help option to show usage information: uv run bin/somescript.py --help Available Scripts af2_combine_scores.py Combines AlphaFold2 scores from multiple predictions into a single summary table. This can be useful to monitor mid-run progress for RFdiffusion pipelines (it's run automatically at the end of the pipeline). Usage: OUTDIR=results uv run bin/af2_combine_scores.py -o $OUTDIR/combined_scores.tsv -p $OUTDIR/af2_results head $OUTDIR/combined_scores.tsv calculate_shape_scores.py Calculates shape-based scoring metrics for protein designs (eg radius of gyration, etc.). create_bindcraft_settings.py Generates BindCraft configuration files. create_boltz_yaml.py Creates YAML configuration files for Boltz predictions. filter_designs.py Main script for the design filter plugin system. Automatically discovers and calls filter plugins based on filter expressions. Required filter plugins in filters.d/ . Could be used for post-pipeline filtering, but is largely intended for internal use. get_contigs.py Extracts 'contig' information from protein structures in RFdiffusion syntax - useful for determining the contig ranges from a hand-cropped structure. merge_scores.py Merges scoring tables from multiple sources. pdb_to_fasta.py Extracts the FASTA sequence of chains in a PDB files. renumber_chains.py Renumbers a chain in a PDB file. trim_to_contigs.py Trims protein structures to specified contig regions, using the RFdiffusion contig syntax. bindcraft_scoring.py Design scoring code extracted from BindCraft - outputs a subset of BindCraft's scores for any set of designs. Required PyRosetta - should be run using the BindCraft container. Filter Plugins Custom filter plugins are located in bin/filters.d/ . Any *.py file in this directory will be automatically discovered. Available Filters rg (radius of gyration) - in bin/filters.d/rg.py Creating Custom Filters Create a new .py file in bin/filters.d/ implementing two functions: 1. register_metrics() -> list[str] Returns list of metric names: def register_metrics() -> list[str]: return [\"rg\", \"my_custom_score\"] 2. calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame Calculates metrics and returns a DataFrame: def calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame: # Perform calculations # Return DataFrame with: # - Index: design ID (PDB filename without .pdb) # - Columns: metric names from register_metrics() return results_df","title":"Utility Scripts"},{"location":"extra/utility-scripts/#utility-scripts","text":"The bin/ directory contains utility scripts that are used internally by the workflows but can also be run as standalone tools.","title":"Utility Scripts"},{"location":"extra/utility-scripts/#running-scripts","text":"Run with uv for automatic dependency management - each script has a --help option to show usage information: uv run bin/somescript.py --help","title":"Running Scripts"},{"location":"extra/utility-scripts/#available-scripts","text":"","title":"Available Scripts"},{"location":"extra/utility-scripts/#af2_combine_scorespy","text":"Combines AlphaFold2 scores from multiple predictions into a single summary table. This can be useful to monitor mid-run progress for RFdiffusion pipelines (it's run automatically at the end of the pipeline). Usage: OUTDIR=results uv run bin/af2_combine_scores.py -o $OUTDIR/combined_scores.tsv -p $OUTDIR/af2_results head $OUTDIR/combined_scores.tsv","title":"af2_combine_scores.py"},{"location":"extra/utility-scripts/#calculate_shape_scorespy","text":"Calculates shape-based scoring metrics for protein designs (eg radius of gyration, etc.).","title":"calculate_shape_scores.py"},{"location":"extra/utility-scripts/#create_bindcraft_settingspy","text":"Generates BindCraft configuration files.","title":"create_bindcraft_settings.py"},{"location":"extra/utility-scripts/#create_boltz_yamlpy","text":"Creates YAML configuration files for Boltz predictions.","title":"create_boltz_yaml.py"},{"location":"extra/utility-scripts/#filter_designspy","text":"Main script for the design filter plugin system. Automatically discovers and calls filter plugins based on filter expressions. Required filter plugins in filters.d/ . Could be used for post-pipeline filtering, but is largely intended for internal use.","title":"filter_designs.py"},{"location":"extra/utility-scripts/#get_contigspy","text":"Extracts 'contig' information from protein structures in RFdiffusion syntax - useful for determining the contig ranges from a hand-cropped structure.","title":"get_contigs.py"},{"location":"extra/utility-scripts/#merge_scorespy","text":"Merges scoring tables from multiple sources.","title":"merge_scores.py"},{"location":"extra/utility-scripts/#pdb_to_fastapy","text":"Extracts the FASTA sequence of chains in a PDB files.","title":"pdb_to_fasta.py"},{"location":"extra/utility-scripts/#renumber_chainspy","text":"Renumbers a chain in a PDB file.","title":"renumber_chains.py"},{"location":"extra/utility-scripts/#trim_to_contigspy","text":"Trims protein structures to specified contig regions, using the RFdiffusion contig syntax.","title":"trim_to_contigs.py"},{"location":"extra/utility-scripts/#bindcraft_scoringpy","text":"Design scoring code extracted from BindCraft - outputs a subset of BindCraft's scores for any set of designs. Required PyRosetta - should be run using the BindCraft container.","title":"bindcraft_scoring.py"},{"location":"extra/utility-scripts/#filter-plugins","text":"Custom filter plugins are located in bin/filters.d/ . Any *.py file in this directory will be automatically discovered.","title":"Filter Plugins"},{"location":"extra/utility-scripts/#available-filters","text":"rg (radius of gyration) - in bin/filters.d/rg.py","title":"Available Filters"},{"location":"extra/utility-scripts/#creating-custom-filters","text":"Create a new .py file in bin/filters.d/ implementing two functions:","title":"Creating Custom Filters"},{"location":"extra/utility-scripts/#1-register_metrics-liststr","text":"Returns list of metric names: def register_metrics() -> list[str]: return [\"rg\", \"my_custom_score\"]","title":"1. register_metrics() -&gt; list[str]"},{"location":"extra/utility-scripts/#2-calculate_metricspdb_files-liststr-binder_chains-liststr-pddataframe","text":"Calculates metrics and returns a DataFrame: def calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame: # Perform calculations # Return DataFrame with: # - Index: design ID (PDB filename without .pdb) # - Columns: metric names from register_metrics() return results_df","title":"2. calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -&gt; pd.DataFrame"},{"location":"workflows/bindcraft/","text":"BindCraft Workflow Parallel BindCraft execution for protein binder design across multiple GPUs. Overview The bindcraft.nf workflow runs BindCraft trajectories in parallel across multiple GPUs - ideal for HPC clusters or multi-GPU workstations. Key Differences Unlike a 'vanilla' BindCraft run which runs on a single GPU indefinitely until finding N accepted designs, this pipeline: Runs a fixed number of trajectories ( --bindcraft_n_traj ) Stops when complete (predictable runtime) Parallelizes across available GPUs Outputs an HTML summary report If you want to generate a specific number of accepted designs, we suggest running a small number of trajectories ( --bindcraft_n_traj 100 or --bindcraft_n_traj 300 ) to assess the acceptance rate, then knowing the ratio of accepted designs to total trajectories, do a larger run to generate (approximately) the desired number of accepted designs. Command-line Options See available options with --help : nextflow run bindcraft.nf --help Example Usage DATESTAMP=$(date +%Y%m%d_%H%M%S) nextflow run bindcraft.nf \\ --input_pdb 'input/PDL1.pdb' \\ --outdir results \\ --target_chains \"A\" \\ --hotspot_res \"A56,A125\" \\ --hotspot_subsample 0.5 \\ --binder_length_range \"55-120\" \\ --bindcraft_n_traj 2 \\ --bindcraft_batch_size 1 \\ --bindcraft_advanced_settings_preset \"default_4stage_multimer\" \\ --bindcraft_filters_preset \"default_filters\" \\ -profile local \\ -resume \\ -with-report results/logs/report_${DATESTAMP}.html \\ -with-trace results/logs/trace_${DATESTAMP}.txt For running on SLURM, you can use the -profile slurm flag instead of -profile local , with --slurm_account=xxYY and the appropriate -c site-specific configuration file (refer to and adapt from the rfdiffusion example ). Key Parameters --input_pdb : Target protein structure --target_chains : Target chain IDs (comma-separated) --hotspot_res : Hotspot residues (comma-separated) --hotspot_subsample : Random proportion of hotspot residues per design (explores hotspot selection) --binder_length_range : Range of binder lengths to design --bindcraft_n_traj : Number of trajectories to run --bindcraft_batch_size : Number of trajectories per batch --gpu_devices : Specify multiple GPUs, e.g., --gpu_devices=0,1 - use only for -profile local BindCraft Presets Advanced Settings Presets --bindcraft_advanced_settings_preset : Use a preset from settings_advanced (without .json extension) Keep in mind, the experimental success rate of the advanced presets may not have been as rigorously validated as the default4stage_multimer preset. Caveat emptor. Filter Presets --bindcraft_filters_preset : Use filter settings presets from settings_filters (without .json extension). In most cases, it's probably best to stick with the default. Output Structure Results are saved to --outdir in the bindcraft/ subdirectory: \u2500\u2500 bindcraft \u2502 \u251c\u2500\u2500 accepted \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u2514\u2500\u2500 Accepted \u2502 \u2502 \u251c\u2500\u2500 bindcraft_design_1_l57_s942028_mpnn6_model1.pdb \u2502 \u2502 \u2514\u2500\u2500 bindcraft_design_1_l57_s942028_mpnn8_model2.pdb \u2502 \u251c\u2500\u2500 batches \u2502 \u2502 \u251c\u2500\u2500 0 \u2502 \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 Trajectory \u2502 \u2502 \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2502 \u2502 \u2514\u2500\u2500 1 \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u251c\u2500\u2500 Accepted \u2502 \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u2502 \u251c\u2500\u2500 MPNN \u2502 \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2502 \u251c\u2500\u2500 Rejected \u2502 \u2502 \u251c\u2500\u2500 Trajectory \u2502 \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2502 \u251c\u2500\u2500 bindcraft_report.html \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2514\u2500\u2500 logs \u251c\u2500\u2500 report_20250725_084959.html \u251c\u2500\u2500 trace_20250725_084959.txt A summary report is generated as bindcraft_report.html . Examples The examples/ directory contains complete working examples for BindCraft workflows: examples/pdl1-bindcraft : PDL1 binder example from the BindCraft repository examples/egfr-bindcraft : an EGFR binder design example examples/mdm2-bindcraft-peptide - peptide binder design for MDM2, based on Filus et al, 2025 See the examples/README.md for details.","title":"BindCraft"},{"location":"workflows/bindcraft/#bindcraft-workflow","text":"Parallel BindCraft execution for protein binder design across multiple GPUs.","title":"BindCraft Workflow"},{"location":"workflows/bindcraft/#overview","text":"The bindcraft.nf workflow runs BindCraft trajectories in parallel across multiple GPUs - ideal for HPC clusters or multi-GPU workstations.","title":"Overview"},{"location":"workflows/bindcraft/#key-differences","text":"Unlike a 'vanilla' BindCraft run which runs on a single GPU indefinitely until finding N accepted designs, this pipeline: Runs a fixed number of trajectories ( --bindcraft_n_traj ) Stops when complete (predictable runtime) Parallelizes across available GPUs Outputs an HTML summary report If you want to generate a specific number of accepted designs, we suggest running a small number of trajectories ( --bindcraft_n_traj 100 or --bindcraft_n_traj 300 ) to assess the acceptance rate, then knowing the ratio of accepted designs to total trajectories, do a larger run to generate (approximately) the desired number of accepted designs.","title":"Key Differences"},{"location":"workflows/bindcraft/#command-line-options","text":"See available options with --help : nextflow run bindcraft.nf --help","title":"Command-line Options"},{"location":"workflows/bindcraft/#example-usage","text":"DATESTAMP=$(date +%Y%m%d_%H%M%S) nextflow run bindcraft.nf \\ --input_pdb 'input/PDL1.pdb' \\ --outdir results \\ --target_chains \"A\" \\ --hotspot_res \"A56,A125\" \\ --hotspot_subsample 0.5 \\ --binder_length_range \"55-120\" \\ --bindcraft_n_traj 2 \\ --bindcraft_batch_size 1 \\ --bindcraft_advanced_settings_preset \"default_4stage_multimer\" \\ --bindcraft_filters_preset \"default_filters\" \\ -profile local \\ -resume \\ -with-report results/logs/report_${DATESTAMP}.html \\ -with-trace results/logs/trace_${DATESTAMP}.txt For running on SLURM, you can use the -profile slurm flag instead of -profile local , with --slurm_account=xxYY and the appropriate -c site-specific configuration file (refer to and adapt from the rfdiffusion example ).","title":"Example Usage"},{"location":"workflows/bindcraft/#key-parameters","text":"--input_pdb : Target protein structure --target_chains : Target chain IDs (comma-separated) --hotspot_res : Hotspot residues (comma-separated) --hotspot_subsample : Random proportion of hotspot residues per design (explores hotspot selection) --binder_length_range : Range of binder lengths to design --bindcraft_n_traj : Number of trajectories to run --bindcraft_batch_size : Number of trajectories per batch --gpu_devices : Specify multiple GPUs, e.g., --gpu_devices=0,1 - use only for -profile local","title":"Key Parameters"},{"location":"workflows/bindcraft/#bindcraft-presets","text":"","title":"BindCraft Presets"},{"location":"workflows/bindcraft/#advanced-settings-presets","text":"--bindcraft_advanced_settings_preset : Use a preset from settings_advanced (without .json extension) Keep in mind, the experimental success rate of the advanced presets may not have been as rigorously validated as the default4stage_multimer preset. Caveat emptor.","title":"Advanced Settings Presets"},{"location":"workflows/bindcraft/#filter-presets","text":"--bindcraft_filters_preset : Use filter settings presets from settings_filters (without .json extension). In most cases, it's probably best to stick with the default.","title":"Filter Presets"},{"location":"workflows/bindcraft/#output-structure","text":"Results are saved to --outdir in the bindcraft/ subdirectory: \u2500\u2500 bindcraft \u2502 \u251c\u2500\u2500 accepted \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u2514\u2500\u2500 Accepted \u2502 \u2502 \u251c\u2500\u2500 bindcraft_design_1_l57_s942028_mpnn6_model1.pdb \u2502 \u2502 \u2514\u2500\u2500 bindcraft_design_1_l57_s942028_mpnn8_model2.pdb \u2502 \u251c\u2500\u2500 batches \u2502 \u2502 \u251c\u2500\u2500 0 \u2502 \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2502 \u2502 \u251c\u2500\u2500 Trajectory \u2502 \u2502 \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2502 \u2502 \u2514\u2500\u2500 1 \u2502 \u2502 \u2514\u2500\u2500 results \u2502 \u2502 \u251c\u2500\u2500 Accepted \u2502 \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u2502 \u251c\u2500\u2500 MPNN \u2502 \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2502 \u251c\u2500\u2500 Rejected \u2502 \u2502 \u251c\u2500\u2500 Trajectory \u2502 \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2502 \u251c\u2500\u2500 bindcraft_report.html \u2502 \u251c\u2500\u2500 failure_csv.csv \u2502 \u251c\u2500\u2500 final_design_stats.csv \u2502 \u251c\u2500\u2500 mpnn_design_stats.csv \u2502 \u2514\u2500\u2500 trajectory_stats.csv \u2514\u2500\u2500 logs \u251c\u2500\u2500 report_20250725_084959.html \u251c\u2500\u2500 trace_20250725_084959.txt A summary report is generated as bindcraft_report.html .","title":"Output Structure"},{"location":"workflows/bindcraft/#examples","text":"The examples/ directory contains complete working examples for BindCraft workflows: examples/pdl1-bindcraft : PDL1 binder example from the BindCraft repository examples/egfr-bindcraft : an EGFR binder design example examples/mdm2-bindcraft-peptide - peptide binder design for MDM2, based on Filus et al, 2025 See the examples/README.md for details.","title":"Examples"},{"location":"workflows/boltz-pulldown/","text":"Boltz Pulldown An experimental AlphaPulldown -like protocol using Boltz for multimer predictions. Overview Boltz Pulldown runs multimer predictions from sequence for all target-binder pairs, allowing you to assess binding interactions between multiple potential interaciton partners. Command-line Options See available options with --help : nextflow run boltz_pulldown.nf --help Multiple Sequence Alignments (MSAs) By default, no MSAs are used . To enable: --create_target_msa=true : Generate MSAs for targets --create_binder_msa=true : Generate MSAs for binders \u26a0\ufe0f For de novo designed binders, use --create_target_msa=true to improve target prediction accuracy, but skip generating binder MSAs ( --create_binder_msa=false , the default) as these are less informative since no homologs exist. MSA Generation Options Option 1: Remote Server --use_msa_server Uses the remote ColabFold mmseqs2 server. Option 2: Local Databases Download and set up databases with the ColabFold setup_databases.sh script, then specify paths: --uniref30 /path/to/uniref30 --colabfold_envdb /path/to/colabfold_envdb Custom Boltz Arguments Add extra Boltz command-line arguments via ext.args in nextflow.config : process { withName: BOLTZ { accelerator = 1 time = 2.hours memory = '8g' cpus = 2 // Example: CPU-only mode ext.args = \"--accelerator cpu\" } } Output Default output directory: results/boltz_pulldown/ Includes: Boltz predictions with scores and structures boltz_pulldown.tsv - summary table boltz_pulldown_report.html - report with statistics and ipTM score plots","title":"Boltz Pulldown"},{"location":"workflows/boltz-pulldown/#boltz-pulldown","text":"An experimental AlphaPulldown -like protocol using Boltz for multimer predictions.","title":"Boltz Pulldown"},{"location":"workflows/boltz-pulldown/#overview","text":"Boltz Pulldown runs multimer predictions from sequence for all target-binder pairs, allowing you to assess binding interactions between multiple potential interaciton partners.","title":"Overview"},{"location":"workflows/boltz-pulldown/#command-line-options","text":"See available options with --help : nextflow run boltz_pulldown.nf --help","title":"Command-line Options"},{"location":"workflows/boltz-pulldown/#multiple-sequence-alignments-msas","text":"By default, no MSAs are used . To enable: --create_target_msa=true : Generate MSAs for targets --create_binder_msa=true : Generate MSAs for binders \u26a0\ufe0f For de novo designed binders, use --create_target_msa=true to improve target prediction accuracy, but skip generating binder MSAs ( --create_binder_msa=false , the default) as these are less informative since no homologs exist.","title":"Multiple Sequence Alignments (MSAs)"},{"location":"workflows/boltz-pulldown/#msa-generation-options","text":"","title":"MSA Generation Options"},{"location":"workflows/boltz-pulldown/#option-1-remote-server","text":"--use_msa_server Uses the remote ColabFold mmseqs2 server.","title":"Option 1: Remote Server"},{"location":"workflows/boltz-pulldown/#option-2-local-databases","text":"Download and set up databases with the ColabFold setup_databases.sh script, then specify paths: --uniref30 /path/to/uniref30 --colabfold_envdb /path/to/colabfold_envdb","title":"Option 2: Local Databases"},{"location":"workflows/boltz-pulldown/#custom-boltz-arguments","text":"Add extra Boltz command-line arguments via ext.args in nextflow.config : process { withName: BOLTZ { accelerator = 1 time = 2.hours memory = '8g' cpus = 2 // Example: CPU-only mode ext.args = \"--accelerator cpu\" } }","title":"Custom Boltz Arguments"},{"location":"workflows/boltz-pulldown/#output","text":"Default output directory: results/boltz_pulldown/ Includes: Boltz predictions with scores and structures boltz_pulldown.tsv - summary table boltz_pulldown_report.html - report with statistics and ipTM score plots","title":"Output"},{"location":"workflows/boltzgen/","text":"BoltzGen Workflow The boltzgen.nf workflow automates the design of binders using the BoltzGen generative model. The key advantage of this workflow is improved parallelization across multiple GPUs and better resource allocation on HPC clusters. It supports the protein-anything , peptide-anything , protein_small-molecule and nanobody-anything protocols. Overview The BoltzGen workflow performs the following steps, as per boltzgen run : Design : Generates binder backbone structures based on a YAML configuration. Inverse Folding : Generates sequences for the designed backbones. Folding : Re-folds the designed binder in complex with the target. Design Folding : Re-folds the designed binder alone. Affinity : (Optional - protein_small-molecule protocol only) Calculates affinity scores for protein-small molecule complexes. ( Merge batches : nf-binder-design bolzgen.nf merges independently generated batches of designs, ready for analysis and filtering) Analysis & Filtering : Aggregates scores and filters designs based on user-defined criteria. General Information Command-line Options You can see available options with --help : nextflow run boltzgen.nf --help YAML Configuration The BoltzGen workflow is controlled by a YAML configuration file passed via --config_yaml . This file defines the input structure, constraints, and design objectives. Refer to the BoltzGen documentation on how to prepare your configuration file. Note: \u26a0\ufe0f BoltzGen expects residues specified as indices starting at 1, irresepctive of the numbering in your PDB/mmCIF file. You may find it easier to use bin/renumber_chains.py to renumber your input PDB to be sequentially numbered starting at 1 to simplify choosing hotspot residues in ChimeraX/Pymol/Molstar etc. Usage Basic Execution To run the workflow with a configuration file: nextflow run boltzgen.nf --config_yaml config/my_design.yaml Key Parameters --config_yaml : (Required) Path to the BoltzGen YAML configuration file. --outdir : Output directory for results (default: results ). --design_name : Name of the design, used for output file prefixes. Defaults to the basename of the config file. --protocol : Protocol type. Options: protein-anything (default) peptide-anything protein-small_molecule nanobody-anything --num_designs : Total number of designs to generate (default: 100). --inverse_fold_num_sequences : Number of sequences to generate per backbone during the inverse folding step (default: 1). --batch_size : Number of designs to process per batch (default: 10). --budget : Final number of designs to keep after diversity optimization and filtering (default: 10). --devices : Number of GPU devices to use (default: 1). --num_workers : Number of DataLoader workers. Filtering Parameters --alpha : Trade-off for sequence diversity selection: 0.0=quality-only, 1.0=diversity-only. --filter_biased : Remove amino-acid composition outliers (default: true, use --filter_biased false to disable). --metrics_override : Per-metric inverse-importance weights for ranking. Format: metric_name=weight (e.g., 'plip_hbonds_refolded=4' 'delta_sasa_refolded=2' ). --additional_filters : Extra hard filters. Format: feature>threshold or feature<threshold (e.g., 'design_ALA>0.3' 'design_GLY<0.2' ). --size_buckets : Constraint for maximum designs in size ranges. Format: min-max:count (e.g., '10-20:5' '20-30:10' ). --refolding_rmsd_threshold : Threshold used for RMSD-based filters (lower is better). Key Outputs The results directory (or specified --outdir ) will contain: params.json : A record of the parameters used for the run. boltzgen/batches : Each independent design batch, in folders for each step ( design , inverse_folding , folding , design_folding ) bolzgen/merged : All batches merged, after the 'analysis' step. boltzgen/filtered : Final designs are in filtered/final_ranked_designs after the 'filtering' step. boltzgen/merged should be equivalent to the output of a non-Nextflow execution of boltzgen run - see the BoltzGen docs for details on the pipeline output . Re-running Filtering Use boltzgen_filter.nf to re-run filtering on existing results with different parameters: nextflow run boltzgen_filter.nf --run results/boltzgen/merged --budget 20 --alpha 0.05 The --config_yaml and --protocol are auto-detected from params.json if not specified. All filtering parameters from the main workflow are available. Results are saved to results/boltzgen/filtered/final_ranked_designs/ . Examples The examples/ directory contains complete working examples for BoltzGen workflows: examples/boltzgen-protein : Protein binder design (protocol protein-anything ) examples/boltzgen-cyclic-peptide : Cyclic peptide binder design (protocol peptide-anything ) examples/boltzgen-small-molecule-binder : Small molecule binder design (protocol protein-small_molecule ) See the examples/README.md for details.","title":"BoltzGen"},{"location":"workflows/boltzgen/#boltzgen-workflow","text":"The boltzgen.nf workflow automates the design of binders using the BoltzGen generative model. The key advantage of this workflow is improved parallelization across multiple GPUs and better resource allocation on HPC clusters. It supports the protein-anything , peptide-anything , protein_small-molecule and nanobody-anything protocols.","title":"BoltzGen Workflow"},{"location":"workflows/boltzgen/#overview","text":"The BoltzGen workflow performs the following steps, as per boltzgen run : Design : Generates binder backbone structures based on a YAML configuration. Inverse Folding : Generates sequences for the designed backbones. Folding : Re-folds the designed binder in complex with the target. Design Folding : Re-folds the designed binder alone. Affinity : (Optional - protein_small-molecule protocol only) Calculates affinity scores for protein-small molecule complexes. ( Merge batches : nf-binder-design bolzgen.nf merges independently generated batches of designs, ready for analysis and filtering) Analysis & Filtering : Aggregates scores and filters designs based on user-defined criteria.","title":"Overview"},{"location":"workflows/boltzgen/#general-information","text":"","title":"General Information"},{"location":"workflows/boltzgen/#command-line-options","text":"You can see available options with --help : nextflow run boltzgen.nf --help","title":"Command-line Options"},{"location":"workflows/boltzgen/#yaml-configuration","text":"The BoltzGen workflow is controlled by a YAML configuration file passed via --config_yaml . This file defines the input structure, constraints, and design objectives. Refer to the BoltzGen documentation on how to prepare your configuration file. Note: \u26a0\ufe0f BoltzGen expects residues specified as indices starting at 1, irresepctive of the numbering in your PDB/mmCIF file. You may find it easier to use bin/renumber_chains.py to renumber your input PDB to be sequentially numbered starting at 1 to simplify choosing hotspot residues in ChimeraX/Pymol/Molstar etc.","title":"YAML Configuration"},{"location":"workflows/boltzgen/#usage","text":"","title":"Usage"},{"location":"workflows/boltzgen/#basic-execution","text":"To run the workflow with a configuration file: nextflow run boltzgen.nf --config_yaml config/my_design.yaml","title":"Basic Execution"},{"location":"workflows/boltzgen/#key-parameters","text":"--config_yaml : (Required) Path to the BoltzGen YAML configuration file. --outdir : Output directory for results (default: results ). --design_name : Name of the design, used for output file prefixes. Defaults to the basename of the config file. --protocol : Protocol type. Options: protein-anything (default) peptide-anything protein-small_molecule nanobody-anything --num_designs : Total number of designs to generate (default: 100). --inverse_fold_num_sequences : Number of sequences to generate per backbone during the inverse folding step (default: 1). --batch_size : Number of designs to process per batch (default: 10). --budget : Final number of designs to keep after diversity optimization and filtering (default: 10). --devices : Number of GPU devices to use (default: 1). --num_workers : Number of DataLoader workers.","title":"Key Parameters"},{"location":"workflows/boltzgen/#filtering-parameters","text":"--alpha : Trade-off for sequence diversity selection: 0.0=quality-only, 1.0=diversity-only. --filter_biased : Remove amino-acid composition outliers (default: true, use --filter_biased false to disable). --metrics_override : Per-metric inverse-importance weights for ranking. Format: metric_name=weight (e.g., 'plip_hbonds_refolded=4' 'delta_sasa_refolded=2' ). --additional_filters : Extra hard filters. Format: feature>threshold or feature<threshold (e.g., 'design_ALA>0.3' 'design_GLY<0.2' ). --size_buckets : Constraint for maximum designs in size ranges. Format: min-max:count (e.g., '10-20:5' '20-30:10' ). --refolding_rmsd_threshold : Threshold used for RMSD-based filters (lower is better).","title":"Filtering Parameters"},{"location":"workflows/boltzgen/#key-outputs","text":"The results directory (or specified --outdir ) will contain: params.json : A record of the parameters used for the run. boltzgen/batches : Each independent design batch, in folders for each step ( design , inverse_folding , folding , design_folding ) bolzgen/merged : All batches merged, after the 'analysis' step. boltzgen/filtered : Final designs are in filtered/final_ranked_designs after the 'filtering' step. boltzgen/merged should be equivalent to the output of a non-Nextflow execution of boltzgen run - see the BoltzGen docs for details on the pipeline output .","title":"Key Outputs"},{"location":"workflows/boltzgen/#re-running-filtering","text":"Use boltzgen_filter.nf to re-run filtering on existing results with different parameters: nextflow run boltzgen_filter.nf --run results/boltzgen/merged --budget 20 --alpha 0.05 The --config_yaml and --protocol are auto-detected from params.json if not specified. All filtering parameters from the main workflow are available. Results are saved to results/boltzgen/filtered/final_ranked_designs/ .","title":"Re-running Filtering"},{"location":"workflows/boltzgen/#examples","text":"The examples/ directory contains complete working examples for BoltzGen workflows: examples/boltzgen-protein : Protein binder design (protocol protein-anything ) examples/boltzgen-cyclic-peptide : Cyclic peptide binder design (protocol peptide-anything ) examples/boltzgen-small-molecule-binder : Small molecule binder design (protocol protein-small_molecule ) See the examples/README.md for details.","title":"Examples"},{"location":"workflows/rfdiffusion/","text":"RFdiffusion Workflows RFdiffusion-based workflows for de novo protein binder design. Overview The RFdiffusion workflows include: main.nf : Complete binder design pipeline (RFdiffusion \u2192 ProteinMPNN \u2192 AlphaFold2 initial guess \u2192 Boltz-2 refolding) partial.nf : Partial diffusion refinement of existing designs or complexes (RFdiffusion Partial Diffusion \u2192 Boltz-2 refolding) General Information Command-line Options For any workflow, you can see available options with --help : nextflow run main.nf --help nextflow run partial.nf --help Parameters File Parameter command-line options (those prefixed with -- ) can also be defined in a params.json file: nextflow run main.nf -params-file params.json eg: { \"hotspot_res\": \"A473,A995,A411,A421\", \"rfd_n_designs\": 10 } Parameter names typically mirror the equivalent command-line options in the underlying tools, often prefixed with rfd_ or pmpnn_ etc. Key Outputs Outputs are stored in the results directory by default (or the path specified by --outdir ). combined_scores.tsv : Combined scores for all designs This file includes the key AF2 initial guess scores pae_interaction and plddt_binder , etc, as well as several shape scores ( rg , dmax , etc), the binder sequence, and some extra BindCraft-style scores. The rfdiffusion proteinmpnn and af2_initial_guess directories contain the intermediate files for these steps. The 'initial guess' complex structures are in af2_initial_guess/pdbs . results/binders.fasta : FASTA sequences of the binders When the --refold_af2ig_filters option is used to do Boltz-2 refolding, combined_scores.tsv includes: boltz_confidence_score and boltz_iptm for the refolded complex boltz_monomer_vs_complex_rmsd_all (the C-alpha RMSD of the binder as an unbound monomer vs the bound form in the refolded complex). Refolded complexes and binder monomers are in results/boltz_refold/predict/complex and results/boltz_refold/predict/monomer , respectively. In this mode, the pipeline only calculates the extra BindCraft-style scores for the Boltz-2 refolded complexes, rather than the AF2 initial guess models. RMSD Comparisons When Boltz-2 refolding is enabled, several C-alpha RMSD comparisons are calculated and saved to results/boltz_refold/rmsd/ : File Superimpose On Measure Interpretation rmsd_target_aligned_binder.tsv Target (B) Binder (A) Binding pose deviation after refolding rmsd_complex_vs_af2ig.tsv Both (A,B) Both (A,B) Overall structural agreement between AF2IG and Boltz rmsd_monomer_vs_af2ig.tsv Binder (A) Binder (A) Binder folding change between bound/unbound (monomer vs AF2IG complex) rmsd_monomer_vs_complex.tsv Binder (A) Binder (A) Binder folding change between bound/unbound (monomer vs Boltz complex) Each file contains rmsd_pruned (aligned core residues only) and rmsd_all (all residues) values. Key metrics for assessing binder quality: rmsd_target_aligned_binder.tsv \u2192 rmsd_all : Low values (<~3.5 \u00c5?) indicate the binder maintains its binding pose relative to the target after Boltz refolding. High values indicate the binder is in a different binding site or pose in the Boltz-2 refolded prediction, relative to the initial AF2 initial guess. This value is included in the combined_scores.tsv file as boltz_target_aligned_binder_rmsd_all . rmsd_monomer_vs_complex.tsv \u2192 rmsd_all : Indicative of possible binder conformational changes upon binding. Low values (<~3.5 \u00c5?) mean the binder structure is similar whether predicted alone or in complex - a good sign for a stable, foldable binder. This value is included in the combined_scores.tsv file as boltz_monomer_vs_complex_rmsd_all . Binder Design with RFdiffusion (main.nf) Single Node or Local Workstation Simple example for local execution: OUTDIR=results mkdir -p $OUTDIR/logs nextflow run main.nf \\ --input_pdb target.pdb \\ --outdir $OUTDIR \\ --contigs \"[A371-508/A753-883/A946-1118/A1135-1153/0 70-100]\" \\ --hotspot_res \"A473,A995,A411,A421\" \\ --rfd_n_designs=10 \\ --rfd_batch_size 1 \\ -with-report $OUTDIR/logs/report_$(date +%Y%m%d_%H%M%S).html \\ -with-trace $OUTDIR/logs/trace_$(date +%Y%m%d_%H%M%S).txt \\ -resume \\ -profile local Parallel tasks on an HPC Cluster Here's a more complex 'kitchen sink' example using -profile slurm,m3 for the M3 HPC cluster: #!/bin/bash # Path to your git clone of this repo WF_PATH=\"/path/to/nf-binder-design\" mkdir -p results/logs DATESTAMP=$(date +%Y%m%d_%H%M%S) # Ensure tmp directory has enough space export TMPDIR=$(realpath ./tmp) export NXF_TEMP=$TMPDIR mkdir -p $TMPDIR # Set apptainer cache directory (change to your scratch path) export NXF_APPTAINER_CACHEDIR=/path/to/scratch2/apptainer_cache export NXF_APPTAINER_TMPDIR=$TMPDIR # Load Nextflow module (if available on your HPC) module load nextflow/24.04.3 || true nextflow run \\ ${WF_PATH}/main.nf \\ --slurm_account=ab12 \\ --input_pdb 'input/target_cropped.pdb' \\ --design_name my-binder \\ --outdir results \\ --contigs \"[B346-521/B601-696/B786-856/0 70-130]\" \\ --hotspot_res \"B472,B476,B484,B488\" \\ --rfd_n_designs=1000 \\ --rfd_batch_size=5 \\ --rfd_filters=\"rg<20\" \\ --rfd_model_path=\"/models/rfdiffusion/Complex_beta_ckpt.pt\" \\ --rfd_extra_args='potentials.guiding_potentials=[\"type:binder_ROG,weight:7,min_dist:10\"] potentials.guide_decay=\"quadratic\"' \\ --pmpnn_seqs_per_struct=2 \\ --pmpnn_relax_cycles=5 \\ --pmpnn_weigths=\"/models/HyperMPNN/retrained_models/v48_020_epoch300_hyper.pt\" \\ --af2ig_recycle=3 \\ --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\" \\ --refold_max=100 \\ --refold_use_msa_server=true \\ --refold_target_fasta='input/full/target.fasta' \\ --refold_target_templates='input/full/' \\ -profile slurm,m3 \\ -resume \\ -with-report results/logs/report_${DATESTAMP}.html \\ -with-trace results/logs/trace_${DATESTAMP}.txt Key Parameters --input_pdb : Target protein structure --contigs : Contig definition for RFdiffusion --hotspot_res : Hotspot residues (comma-separated) --rfd_n_designs : Number of designs to generate --rfd_filters : Filter expression (e.g., \"rg<20\" ) --rfd_model_path : Path to a custom RFdiffusion model (in this case the Complex_beta_ckpt.pt model inside the container) --rfd_extra_args : Pass these extra arguments to RFdiffusion - in this example we apply a radius of gyration potential --pmpnn_seqs_per_struct=2 : Generate 2 sequences per backbone design with ProteinMPNN --pmpnn_relax_cycles=5 : Run 5 FastRelax cycles for ProteinMPNN --pmpnn_weights : Use custom ProteinMPNN weights (in this case the HyperMPNN weights inside the container) --af2ig_recycle=3 : Run 3 recycles for AF2 initial guess When --refold_af2ig_filters is set, designs that pass these score thresholds are refolded using Boltz-2 (both the complex and unbound binder monomer): --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\" : Filter AF2 initial guess designs by PAE interaction <= 10 and binder pLDDT >= 80 --refold_max=100 : Refold a maximum of 100 designs --refold_use_msa_server=true : Use the public ColabFold MMSeqs2 server to generate the MSA for the target sequence --refold_target_fasta='input/full/target.fasta' : Refold (re-predict) using this target sequence --refold_target_templates='input/full/' : Use the full length target template PDBs in this directory to improve target predictions We use -profile slurm,m3 to use pre-defined configuration files specific to the M3 HPC cluster. You could also use the -c flag to point to a custom configuration file. --slurm_account=<your_account_id> is required if you have multiple SLURM accounts and need to use a specific one. Other site-specific -profile options are provided in conf/platforms/ : m3 - Monash M3 cluster m3_bdi - Monash M3 cluster with access to the bdi partitions mlerp - the MLeRP HPC cluster These can be adapted to other HPC clusters - pull requests are welcome ! Partial Diffusion on Binder Designs (partial.nf) Refine existing binder designs with partial diffusion: OUTDIR=results mkdir -p $OUTDIR/logs # Generate 10 partial designs for each binder, in batches of 5 # Note the 'single quotes' around the '*.pdb' glob pattern! nextflow run partial.nf \\ --input_pdb 'my_designs/*.pdb' \\ --rfd_n_partial_per_binder=10 \\ --rfd_batch_size=5 \\ --hotspot_res \"A473,A995,A411,A421\" \\ --rfd_partial_T=2,5,10,20 \\ -with-report $OUTDIR/logs/report_$(date +%Y%m%d_%H%M%S).html \\ -with-trace $OUTDIR/logs/trace_$(date +%Y%m%d_%H%M%S).txt \\ -profile local The other --refold_ parameters, as used above for the main.nf workflow, can also be used here if you'd like to refold the best designs with Boltz-2. \u26a0\ufe0f Note - if you are applying partial diffusion to designs output from the main.nf workflow, the binder will be chain A, with other chains named B, C, etc., regardless of the original target PDB chain IDs. Residue numbering is sequential 1 to N. Your hotspots should be adjusted to account for this ! Design Filter Plugin System The main.nf and partial.nf pipelines support custom metric calculation and filtering via plugins. Using Filters Filtering backbone designs from RFdiffusion by radius of gyration (before passing to ProteinMPNN and AF2 initial guess): --rfd_filters=\"rg<20\" Filtering AF2 initial guess designs before refolding with Boltz-2 by any of the af2ig scores ( pae_interaction , binder_aligned_rmsd , pae_binder , pae_target , plddt_binder , plddt_target , plddt_total , target_aligned_rmsd ), as well as size/shape scores ( rg , dmax , asphericity , approx_rh ). --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\" Available Filters Filters are Python scripts in bin/filters.d/ . Currently available: rg (radius of gyration) - in bin/filters.d/rg.py Creating Custom Filters Create a new .py file in bin/filters.d/ implementing two functions: 1. register_metrics() -> list[str] Returns list of metric names: def register_metrics() -> list[str]: return [\"rg\", \"my_custom_score\"] 2. calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame Calculates metrics and returns a DataFrame: def calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame: # Perform calculations # Return DataFrame with: # - Index: design ID (PDB filename without .pdb) # - Columns: metric names from register_metrics() return results_df The bin/filter_designs.py script automatically discovers and calls plugins based on filter expressions. Examples The examples/ directory contains complete working examples for RFdiffusion workflows: examples/pdl1-rfd : binder design with RFdiffusion + ProteinMPNN + AlphaFold2 initial guess examples/pdl1-rfd-partial : partial diffusion of existing designs examples/egfr-rfd-hypermpnn : binder design with inverse folding using the HyperMPNN weights","title":"RFdiffusion"},{"location":"workflows/rfdiffusion/#rfdiffusion-workflows","text":"RFdiffusion-based workflows for de novo protein binder design.","title":"RFdiffusion Workflows"},{"location":"workflows/rfdiffusion/#overview","text":"The RFdiffusion workflows include: main.nf : Complete binder design pipeline (RFdiffusion \u2192 ProteinMPNN \u2192 AlphaFold2 initial guess \u2192 Boltz-2 refolding) partial.nf : Partial diffusion refinement of existing designs or complexes (RFdiffusion Partial Diffusion \u2192 Boltz-2 refolding)","title":"Overview"},{"location":"workflows/rfdiffusion/#general-information","text":"","title":"General Information"},{"location":"workflows/rfdiffusion/#command-line-options","text":"For any workflow, you can see available options with --help : nextflow run main.nf --help nextflow run partial.nf --help","title":"Command-line Options"},{"location":"workflows/rfdiffusion/#parameters-file","text":"Parameter command-line options (those prefixed with -- ) can also be defined in a params.json file: nextflow run main.nf -params-file params.json eg: { \"hotspot_res\": \"A473,A995,A411,A421\", \"rfd_n_designs\": 10 } Parameter names typically mirror the equivalent command-line options in the underlying tools, often prefixed with rfd_ or pmpnn_ etc.","title":"Parameters File"},{"location":"workflows/rfdiffusion/#key-outputs","text":"Outputs are stored in the results directory by default (or the path specified by --outdir ). combined_scores.tsv : Combined scores for all designs This file includes the key AF2 initial guess scores pae_interaction and plddt_binder , etc, as well as several shape scores ( rg , dmax , etc), the binder sequence, and some extra BindCraft-style scores. The rfdiffusion proteinmpnn and af2_initial_guess directories contain the intermediate files for these steps. The 'initial guess' complex structures are in af2_initial_guess/pdbs . results/binders.fasta : FASTA sequences of the binders When the --refold_af2ig_filters option is used to do Boltz-2 refolding, combined_scores.tsv includes: boltz_confidence_score and boltz_iptm for the refolded complex boltz_monomer_vs_complex_rmsd_all (the C-alpha RMSD of the binder as an unbound monomer vs the bound form in the refolded complex). Refolded complexes and binder monomers are in results/boltz_refold/predict/complex and results/boltz_refold/predict/monomer , respectively. In this mode, the pipeline only calculates the extra BindCraft-style scores for the Boltz-2 refolded complexes, rather than the AF2 initial guess models.","title":"Key Outputs"},{"location":"workflows/rfdiffusion/#rmsd-comparisons","text":"When Boltz-2 refolding is enabled, several C-alpha RMSD comparisons are calculated and saved to results/boltz_refold/rmsd/ : File Superimpose On Measure Interpretation rmsd_target_aligned_binder.tsv Target (B) Binder (A) Binding pose deviation after refolding rmsd_complex_vs_af2ig.tsv Both (A,B) Both (A,B) Overall structural agreement between AF2IG and Boltz rmsd_monomer_vs_af2ig.tsv Binder (A) Binder (A) Binder folding change between bound/unbound (monomer vs AF2IG complex) rmsd_monomer_vs_complex.tsv Binder (A) Binder (A) Binder folding change between bound/unbound (monomer vs Boltz complex) Each file contains rmsd_pruned (aligned core residues only) and rmsd_all (all residues) values. Key metrics for assessing binder quality: rmsd_target_aligned_binder.tsv \u2192 rmsd_all : Low values (<~3.5 \u00c5?) indicate the binder maintains its binding pose relative to the target after Boltz refolding. High values indicate the binder is in a different binding site or pose in the Boltz-2 refolded prediction, relative to the initial AF2 initial guess. This value is included in the combined_scores.tsv file as boltz_target_aligned_binder_rmsd_all . rmsd_monomer_vs_complex.tsv \u2192 rmsd_all : Indicative of possible binder conformational changes upon binding. Low values (<~3.5 \u00c5?) mean the binder structure is similar whether predicted alone or in complex - a good sign for a stable, foldable binder. This value is included in the combined_scores.tsv file as boltz_monomer_vs_complex_rmsd_all .","title":"RMSD Comparisons"},{"location":"workflows/rfdiffusion/#binder-design-with-rfdiffusion-mainnf","text":"","title":"Binder Design with RFdiffusion (main.nf)"},{"location":"workflows/rfdiffusion/#single-node-or-local-workstation","text":"Simple example for local execution: OUTDIR=results mkdir -p $OUTDIR/logs nextflow run main.nf \\ --input_pdb target.pdb \\ --outdir $OUTDIR \\ --contigs \"[A371-508/A753-883/A946-1118/A1135-1153/0 70-100]\" \\ --hotspot_res \"A473,A995,A411,A421\" \\ --rfd_n_designs=10 \\ --rfd_batch_size 1 \\ -with-report $OUTDIR/logs/report_$(date +%Y%m%d_%H%M%S).html \\ -with-trace $OUTDIR/logs/trace_$(date +%Y%m%d_%H%M%S).txt \\ -resume \\ -profile local","title":"Single Node or Local Workstation"},{"location":"workflows/rfdiffusion/#parallel-tasks-on-an-hpc-cluster","text":"Here's a more complex 'kitchen sink' example using -profile slurm,m3 for the M3 HPC cluster: #!/bin/bash # Path to your git clone of this repo WF_PATH=\"/path/to/nf-binder-design\" mkdir -p results/logs DATESTAMP=$(date +%Y%m%d_%H%M%S) # Ensure tmp directory has enough space export TMPDIR=$(realpath ./tmp) export NXF_TEMP=$TMPDIR mkdir -p $TMPDIR # Set apptainer cache directory (change to your scratch path) export NXF_APPTAINER_CACHEDIR=/path/to/scratch2/apptainer_cache export NXF_APPTAINER_TMPDIR=$TMPDIR # Load Nextflow module (if available on your HPC) module load nextflow/24.04.3 || true nextflow run \\ ${WF_PATH}/main.nf \\ --slurm_account=ab12 \\ --input_pdb 'input/target_cropped.pdb' \\ --design_name my-binder \\ --outdir results \\ --contigs \"[B346-521/B601-696/B786-856/0 70-130]\" \\ --hotspot_res \"B472,B476,B484,B488\" \\ --rfd_n_designs=1000 \\ --rfd_batch_size=5 \\ --rfd_filters=\"rg<20\" \\ --rfd_model_path=\"/models/rfdiffusion/Complex_beta_ckpt.pt\" \\ --rfd_extra_args='potentials.guiding_potentials=[\"type:binder_ROG,weight:7,min_dist:10\"] potentials.guide_decay=\"quadratic\"' \\ --pmpnn_seqs_per_struct=2 \\ --pmpnn_relax_cycles=5 \\ --pmpnn_weigths=\"/models/HyperMPNN/retrained_models/v48_020_epoch300_hyper.pt\" \\ --af2ig_recycle=3 \\ --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\" \\ --refold_max=100 \\ --refold_use_msa_server=true \\ --refold_target_fasta='input/full/target.fasta' \\ --refold_target_templates='input/full/' \\ -profile slurm,m3 \\ -resume \\ -with-report results/logs/report_${DATESTAMP}.html \\ -with-trace results/logs/trace_${DATESTAMP}.txt","title":"Parallel tasks on an HPC Cluster"},{"location":"workflows/rfdiffusion/#key-parameters","text":"--input_pdb : Target protein structure --contigs : Contig definition for RFdiffusion --hotspot_res : Hotspot residues (comma-separated) --rfd_n_designs : Number of designs to generate --rfd_filters : Filter expression (e.g., \"rg<20\" ) --rfd_model_path : Path to a custom RFdiffusion model (in this case the Complex_beta_ckpt.pt model inside the container) --rfd_extra_args : Pass these extra arguments to RFdiffusion - in this example we apply a radius of gyration potential --pmpnn_seqs_per_struct=2 : Generate 2 sequences per backbone design with ProteinMPNN --pmpnn_relax_cycles=5 : Run 5 FastRelax cycles for ProteinMPNN --pmpnn_weights : Use custom ProteinMPNN weights (in this case the HyperMPNN weights inside the container) --af2ig_recycle=3 : Run 3 recycles for AF2 initial guess When --refold_af2ig_filters is set, designs that pass these score thresholds are refolded using Boltz-2 (both the complex and unbound binder monomer): --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\" : Filter AF2 initial guess designs by PAE interaction <= 10 and binder pLDDT >= 80 --refold_max=100 : Refold a maximum of 100 designs --refold_use_msa_server=true : Use the public ColabFold MMSeqs2 server to generate the MSA for the target sequence --refold_target_fasta='input/full/target.fasta' : Refold (re-predict) using this target sequence --refold_target_templates='input/full/' : Use the full length target template PDBs in this directory to improve target predictions We use -profile slurm,m3 to use pre-defined configuration files specific to the M3 HPC cluster. You could also use the -c flag to point to a custom configuration file. --slurm_account=<your_account_id> is required if you have multiple SLURM accounts and need to use a specific one. Other site-specific -profile options are provided in conf/platforms/ : m3 - Monash M3 cluster m3_bdi - Monash M3 cluster with access to the bdi partitions mlerp - the MLeRP HPC cluster These can be adapted to other HPC clusters - pull requests are welcome !","title":"Key Parameters"},{"location":"workflows/rfdiffusion/#partial-diffusion-on-binder-designs-partialnf","text":"Refine existing binder designs with partial diffusion: OUTDIR=results mkdir -p $OUTDIR/logs # Generate 10 partial designs for each binder, in batches of 5 # Note the 'single quotes' around the '*.pdb' glob pattern! nextflow run partial.nf \\ --input_pdb 'my_designs/*.pdb' \\ --rfd_n_partial_per_binder=10 \\ --rfd_batch_size=5 \\ --hotspot_res \"A473,A995,A411,A421\" \\ --rfd_partial_T=2,5,10,20 \\ -with-report $OUTDIR/logs/report_$(date +%Y%m%d_%H%M%S).html \\ -with-trace $OUTDIR/logs/trace_$(date +%Y%m%d_%H%M%S).txt \\ -profile local The other --refold_ parameters, as used above for the main.nf workflow, can also be used here if you'd like to refold the best designs with Boltz-2. \u26a0\ufe0f Note - if you are applying partial diffusion to designs output from the main.nf workflow, the binder will be chain A, with other chains named B, C, etc., regardless of the original target PDB chain IDs. Residue numbering is sequential 1 to N. Your hotspots should be adjusted to account for this !","title":"Partial Diffusion on Binder Designs (partial.nf)"},{"location":"workflows/rfdiffusion/#design-filter-plugin-system","text":"The main.nf and partial.nf pipelines support custom metric calculation and filtering via plugins.","title":"Design Filter Plugin System"},{"location":"workflows/rfdiffusion/#using-filters","text":"Filtering backbone designs from RFdiffusion by radius of gyration (before passing to ProteinMPNN and AF2 initial guess): --rfd_filters=\"rg<20\" Filtering AF2 initial guess designs before refolding with Boltz-2 by any of the af2ig scores ( pae_interaction , binder_aligned_rmsd , pae_binder , pae_target , plddt_binder , plddt_target , plddt_total , target_aligned_rmsd ), as well as size/shape scores ( rg , dmax , asphericity , approx_rh ). --refold_af2ig_filters=\"pae_interaction<=10;plddt_binder>=80\"","title":"Using Filters"},{"location":"workflows/rfdiffusion/#available-filters","text":"Filters are Python scripts in bin/filters.d/ . Currently available: rg (radius of gyration) - in bin/filters.d/rg.py","title":"Available Filters"},{"location":"workflows/rfdiffusion/#creating-custom-filters","text":"Create a new .py file in bin/filters.d/ implementing two functions:","title":"Creating Custom Filters"},{"location":"workflows/rfdiffusion/#1-register_metrics-liststr","text":"Returns list of metric names: def register_metrics() -> list[str]: return [\"rg\", \"my_custom_score\"]","title":"1. register_metrics() -&gt; list[str]"},{"location":"workflows/rfdiffusion/#2-calculate_metricspdb_files-liststr-binder_chains-liststr-pddataframe","text":"Calculates metrics and returns a DataFrame: def calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -> pd.DataFrame: # Perform calculations # Return DataFrame with: # - Index: design ID (PDB filename without .pdb) # - Columns: metric names from register_metrics() return results_df The bin/filter_designs.py script automatically discovers and calls plugins based on filter expressions.","title":"2. calculate_metrics(pdb_files: list[str], binder_chains: list[str]) -&gt; pd.DataFrame"},{"location":"workflows/rfdiffusion/#examples","text":"The examples/ directory contains complete working examples for RFdiffusion workflows: examples/pdl1-rfd : binder design with RFdiffusion + ProteinMPNN + AlphaFold2 initial guess examples/pdl1-rfd-partial : partial diffusion of existing designs examples/egfr-rfd-hypermpnn : binder design with inverse folding using the HyperMPNN weights","title":"Examples"}]}